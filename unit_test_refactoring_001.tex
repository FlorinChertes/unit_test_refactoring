\documentclass{article}
\usepackage{amsthm}
\newtheorem{definition}{Definition}
\usepackage{graphicx}

\title{unit test and refactoring}
\date{2022-06-18}
\author{Dino Madach, Thomas Grim-Schlink and Florin Ioan Chertes}

\begin{document}

\maketitle
\pagenumbering{gobble}
\newpage
\pagenumbering{arabic}


\begin{abstract}
Unit test and refactoring are processes that go hand in hand with the purpose fostering the creation of high source code quality. These both processes make the maintainability of the source code manageable and prepare it for reliable change.
\end{abstract}

\section{Introduction}

As Beck \cite{BecAnd04extreme, beck2001planning} explains, testing is one of the most important parts of the discipline Extreme Programming (XP). In his view development is driven by tests, you test first, then you code. When all the tests run, and you can't think of any more tests that would break, you are done adding functionality. He mentions the importance of integration tests that follow immediately the development. Automated test give the possibility to defer the important design decisions as late as possible when the requirements are better understood. Feedback is one of the most important values of XP. Feedback works at different time scales. The programmers write unit tests for all the logic in program that could break. The customers write stories (description of features, simplified use-cases). The testers write functional testes, business functionality for all stories. So the unit tests, written by developers and the functional tests written by customers and testers are the hard of the XP.   

\begin{definition}
   (Unit Test): Unit Test.
\end{definition}

\begin{definition}
  (Functinal test): Functional test.
\end{definition}


\section{Unit Test}

\subsection{Unit Test in Detail}
Feather \cite{FeathersMichael} says that the concept of unit test is about the idea that they are tests in isolation of individual software components. But what are components? The definition could vary, but in unit tests we are usually concerned with the most atomic behavioral units of the system. In object oriented code the units are the classes.

\subsection{Are the classes or the modules the support of the behaviour?}

The TDD was wrong understood and used, says Cooper \cite{WEBSITE:WhereDidItAllGoWrong} 
Heinemeier Hansson \cite{WEBSITE:TDDisdead} says even that TDD is dead.

test behaviour, 
	this is the stabil contract of the API, 
do not test implementation details, 
	these details can change very rapidly

test the implementation details 
	only when you need to understand the re-factoring of the implementation,
	afterwords delete these tests.



common TDD practice by using: 
	'adding a new method to a class' 
	as the trigger to write a test.

Adding a new class is not the trigger for writing tests.
The trigger is implementing a requirement.

Test the public exposed API of the module under test.
Write test to cover the use cases or stories, use the model: Given, When, Then

SUT is not a class
SUT is the export from a module- its facade

Unit means a module not a class
modules consist of many classes that constitute the implementation detail.

Kent Beck, TDD By Example
[...] what set of tests, when passed, will demonstrate the presence of code, we are confident, will compute correctly?

the object of TDD ist to test behaviour in the system

Kent Beck whet runs in isolation ist the test not class using mocks to be isolates.
The test is isolated not the SUT.

unit test of the nodule
integration test
system test

use fixtures to put your unit teste to use the file system, database, etc.

Writing tests that target a method on a class, ist not a TDD developer test.
TDD unit tests focus on a story, use-case, scenario, etc.

unit test focusing on method are hard to maintain, 
	these tests do not capture the behaviour they want to preserve.
	
detail implementation exposed to unit tests make re-factoring difficult	

you do not write new unit teste when re-factoring to clean code.

Eliminate the dependency between tests an production code.
Teste must not depend on implemenation details because changing the implementation breaks the tests.
Tests must depend on contracts or public interfaces.
This allows for re-factor implementation without changing tests.
Do not teste implementation details, they change quickly.

Do not use Mocks to confirm implementation details


Coplien \cite{WEBSITE:UnitTestIsWaste} considers unit tests a waste. His observation is: to automate integration tests, bug regression tests and system tests than by automating unit tests. 

A smarter approach would reduce the test code mass through formal test design: that is, to do formal boundary-condition checking, more white-box testing, and so forth. That requires that the unit under test be designed for testability. This is how hardware engineers do it: designers provide "test points" that can read out values on a J-Tag pin of a chip, to access internal signal values of the chip — tantamount to accessing values between intermediate computations in a computational unit. I advocate doing this at the system level where the testing focus should lie; I have never seen anyone achieve this at the unit level. Without such hooks you are limited to black-box unit testing. 

Tests should be designed with great care. Business people, rather than programmers, should design most functional tests. Unit tests should be limited to those that can be held up against some “third-party” success criteria.

[...] they had written their tests in such a way that they didn't have to change the tests when the functionality changed. That of course means that the tests  weren't testing the functionality, so whatever they were testing was of little value. Those have no provable value. There were methodologies in the 1970s and 1980s based on traceability that tried to reduce system requirements all the way down to the unit level. In general, that's an NP-hard problem (unless you are doing pure procedural decomposition) so I'm very sceptical of anyone who says they can do that. So one question to ask about every test is: If this test fails, what business requirement is compromised? Most of the time, the answer is, "I don't know." If you don't know the value of the test, then the test theoretically could have zero business value. The test does have a cost: maintenance, computing time, administration, and so forth. That means the test could have net negative value. That is the fourth category of tests to remove. These are tests which, though they may even do some amount of verification, do no validation.

\section{next Section }

Next section



\subsection{Conclusion}

Conclusion

\newpage

\bibliography{unit_test_refactoring_001} 
\bibliographystyle{ieeetr}


\end{document}




